---
title: "アルパカでもわかる安全なPodの終了"
emoji: "🦙"
type: "tech"
topics: ["kubernetes"]
published: false
---

これはなに
---
KubernetesにおいてPodが終了するまでの動作を整理し、それを踏まえて、安全な（リクエストの欠損を極小化した）オンラインのローリングアップデートを実現するためにどうすればいいかを考察します。

<!-- ### 想定する前提知識

- 突き合わせループの概念を理解している
- KubernetesのDeployment, Service, Podリソースを使ったことがある -->

TD;LR
---


目次
---

1. Podが終了するまでの過程
2. 安全なPodの終了のために注意すべきこと
3. 検証してみた


1 . Podが終了するまでの過程
---
Podが終了するまでの動作は、@superbrothersさんによる[詳解 Pods の終了](https://qiita.com/superbrothers/items/3ac78daba3560ea406b2)に詳しくまとめられています。
数年前の記事にはなりますが、[公式ドキュメント]()を見たところ今でもそのまま当てはまると考えて良さそうです。

<!-- というわけでこの章は「そちらをご覧ください！」で終わってもよいのですが、それではあまりにも身も蓋もないので、ここでは「これはなに」にある目標を達成するために必要な情報に絞って整理したいと思います。 -->

### Podが終了する過程
コンテナイメージの更新や `kubectl delete pod` の実行など、Podの終了のトリガーとなる事象が起きると、それまで起動していたPodに対する終了処理が開始されます。
Podの終了処理の全体の流れは以下のとおりです。

1. Podの終了予定時刻をPodリソースに設定する
2. Podリソースをウォッチする複数のコンポーネントが、それぞれの終了処理を実行する
    - 2-a. kubeletによるプロセスのシャットダウン
    - 2-b. endpoints controllerとkube-proxyによるサービスアウト
    - 2-c. Ownerリソースによる管理からの除外

2.の3つの処理は、それぞれを担当するコンポーネントが独立して実行します。
このため、例えば「サービスアウトしてからシャットダウンする」といったような互いに依存関係を持った制御は行われません。
これは、本エントリーのテーマのひとつである、「Podの安全な終了」を考える上で重要なポイントになりますので、注意してください。

<!-- 図 -->

以降は、上に挙げた各処理において具体的にどのような処理が行われているかを説明します。

#### 1 . Podの終了予定時刻をPodリソースに設定する
削除対象しようとしているPodに対応するPodリソースに対して、 `deletionTimestamp` と `deletionGracePeriodSeconds` が設定されます。

- `deletionTimestamp` :
    - 削除予定時刻。このフィールドの設定時点に `.spec.terminationGracePeriodSeconds` の値（デフォルト: 30秒）を加算した値が設定される
- `deletionGracePeriodSeconds` : 
    - ほげ

これをきっかけに、Podリソースをウォッチしている各コンポーネントが後続の終了処理を開始します。

#### 2-a. kubeletによるプロセスのシャットダウン
Podリソースに `deletionTimestamp` が設定されたことを検知すると、kubeletは以下のシャットダウンプロセスを開始します。

- 2-a-1. preStopフックを実行する
- 2-a-2. コンテナにSIGTERMシグナルを送る
- 2-a-3. コンテナにSIGKILLシグナルを送る

preStopフックは、プロセスの終了前に実行する事前処理で `pod.spec.containers[].lifecycle.preStop` に処理内容を記述することができます。
指定可能な処理は、任意のコマンドの実行、所定のエンドポイントへのHTTP GETリクエスト、TCPソケットのオープンの試行、の3種です。

preSropフックが終了すると、コンテナにSIGTERMシグナルが送信されます。
多くのアプリケーションでは、SIGTERMの受信を受けて終了処理を開始するように実装することが多いと思います(Gracefl Shutdown)。

SIGTERMの送信後、`deletionTimestamp` に設定された時刻が来てもコンテナが終了していない場合、SIGKILLシグナルが送信されます。
ここで、コンテナが強制的にシャットダウンされます。

##### コンテナが終了するまでの時間
コンテナのシャットダウンの3ステップと、 `deletionTimestamp` の関係を図にすると、以下の通りとなります。
`deletionTimestamp` の時刻までにどのステップまで終了しているかによって、動作が異なりまうｓ．

###### preStopフックが `deletionTimestamp` までに終了しなかった場合
<!-- 図 -->

###### SIGTERM送信後 `deletionTimestamp` までにコンテナが終了しなかった場合
<!-- 図 -->

###### SIGTERM送信後 `deletionTimestamp` までにコンテナが終了した場合
<!-- 図 -->

#### 2-b. endpoints controllerとkube-proxyによるサービスアウト





#### 2-c. Ownerリソースによる管理からの除外

### Podの終了するまでの過程のまとめ

### 安全なPodの終了のために注意すべきこと


2 . 安全なPodの終了のために注意すべきこと
---


3 . 検証してみた
---